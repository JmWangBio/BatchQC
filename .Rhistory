runApp('inst/shiny')
runApp('inst/shiny')
names(colData(se)
names(colData(se))
names(colData(se))
?filter
list.filter(names(colData9se))
list.filter(names(colData(se))
list.filter(names(colData(se)))
names(colData(se)
names = names(colData(se))
names != 'Batch'
names[names != 'Batch']
runApp('inst/shiny')
runApp()
runApp('inst/shiny')
shiny::runApp('inst/shiny')
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
batch_design(se, "category")
# Functions for importing data
library(SummarizedExperiment)
library(dplyr)
library(tidyr)
ingest_data <- function(counts_path, metadata_path){
# Read in counts (assuming first column is index)
counts <- read.csv(counts_path, row.names=1)
# Read in metadata
md <- read.csv(metadata_path, row.names='Sample')
# CHECK that "Sample" and "Batch" columns are in md
## ^^ Is this something that the SE handles?
# Ingest into SummarizedExperiment
se <- SummarizedExperiment(list(counts=counts), colData=md)
return(se)
}
batch_design <- function(se, covariate){
# Create a batch design table for the provided covariate
design = colData(se) %>% as_tibble %>% group_by(eval(as.symbol(covariate))) %>% count(Batch) %>% pivot_wider(names_from = Batch, values_from = n)
return(design)
}
> se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
> batch_design(se, "category")
\se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv') batch_design(se, "category")
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv') batch_design(se, "category")
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
batch_design(se, "category")
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
cols = names(colData(se))
covs = names[names != 'Batch']
colData(se)
names(colData(se))
cols
cols != 'Batch'
shiny::runApp('inst/shiny')
shiny::runApp('inst/shiny')
runApp('inst/shiny')
runApp('inst/shiny')
shiny::runApp('inst/shiny')
shiny::runApp('inst/shiny')
install.packages("shinythemes")
runApp('inst/shiny')
runApp()
runApp('inst/shiny')
runApp()
runApp()
runApp('inst/shiny')
se <- ingest_data('~/BatchQC/data/protein_data.csv')
se <- ingest_data('~/BatchQC/data/protein_data.csv', '')
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
se
bd <- batch_design(se, 'conditions')
View(se)
bd <- batch_design(se, 'category')
bd
?cor
cor(bd)
matrix(bd)
bd\
bd
as.matrix(bd)
as.matrix(bd[2:])
as.matrix(bd[2:end])
bd[2:end]
bd[2:]
bd[2::]
bd[2,]
bd[,[2,]]
bd
bd["1"]
bd[1]
bd[2]
bd[3]
bd
bd[2:]
bd[2,]
bd[:,2,]
bd[,2,]
bd[,2, ]
bd[, -1,]
cor(bd[, -1,])
rcor(bd[, -1,])
rcorr(bd[, -1,])
cor.test()
?cor.test
cor.test(bd[, -1,])
bd
bd
m = bd[, -1, ]
m
rowsum(m)
sum(m)
?sum
as.matrix(m)
rowsum(as.matrix(m))
?rowsum
rowSums(bd)
rowSums(m)
apply(m, 1, sum)
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
counts = table(condition, batch)
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(counts), ncol(counts))
for (i in 1:nrow(counts)) {
for (j in 1:ncol(counts)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((counts - expected)^2/expected)
mmin = min(nrow(counts), ncol(counts))
return(chi, mmin, tablesum)
}
cor_props(bd)
bd
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(counts), ncol(counts))
for (i in 1:nrow(counts)) {
for (j in 1:ncol(counts)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((counts - expected)^2/expected)
mmin = min(nrow(counts), ncol(counts))
return(chi, mmin, tablesum)
}
cor_props(bd)
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(m), ncol(m))
for (i in 1:nrow(counts)) {
for (j in 1:ncol(counts)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((counts - expected)^2/expected)
mmin = min(nrow(counts), ncol(counts))
return(chi, mmin, tablesum)
}
cor_props(bd)
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(m), ncol(m))
for (i in 1:nrow(m)) {
for (j in 1:ncol(m)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((counts - expected)^2/expected)
mmin = min(nrow(counts), ncol(counts))
return(chi, mmin, tablesum)
}
cor_props(bd)
cor_props(bd)
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(m), ncol(m))
for (i in 1:nrow(m)) {
for (j in 1:ncol(m)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((m - expected)^2/expected)
mmin = min(nrow(counts), ncol(counts))
return(chi, mmin, tablesum)
}
cor_props(bd)
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(m), ncol(m))
for (i in 1:nrow(m)) {
for (j in 1:ncol(m)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((m - expected)^2/expected)
mmin = min(nrow(m), ncol(m))
return(chi, mmin, tablesum)
}
cor_props(bd)
cor_props
cor_props <- function(bd){
#' Calculate correlation properties on a batch_design matrix `bd`
# Subset matrix to design only
m = bd[, -1, ]
rowsums = rowSums(m)
colsums = colSums(m)
tablesum = sum(rowsums)
expected = matrix(0, nrow(m), ncol(m))
for (i in 1:nrow(m)) {
for (j in 1:ncol(m)) {
expected[i, j] = rowsums[i] * colsums[j]/tablesum
}
}
chi = sum((m - expected)^2/expected)
mmin = min(nrow(m), ncol(m))
out = list("chi" = chi, "mmin"=mmin, "tablesum"=tablesum)
return(out)
}
cor_props
cor_props(bd)
std_pearson_corr_coef <- function(bd) {
#' Calculate standardized Pearson correlation coefficient
c <- cor_props(bd)
r <- sqrt(c$chi * c$mmin/((c$chi + c$tablesum) * (c$mmin - 1)))
return(r)
}
cramers_v <- function(bd) {
# Calculate Cramer's V
c <- cor_props(bd)
v <- sqrt(c$chi/(c$tablesum * (c$mmin - 1)))
return(v)
}
std_pearson_corr_coef(bd)
cramers_v(bd)
se
View(se)
cols <- names(colData(se))
covs <- cols[cols != 'Batch']
vos
covs
metadata(se)
metadata(se)$covariates <- covs
metadata(se)$covariates
runApp('inst/shiny')
runApp('inst/shiny')
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
md <- read.csv(metadata_path, row.names=1,header=T)
md <- read.csv('~/BatchQC/data/protein_md.csv', row.names=1,header=T)
md
names(md)
runApp('inst/shiny')
es
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
metadata(se)$covariates
runApp('inst/shiny')
se
covs
list(covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers"))
for z in list(covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers"))
for (z in list(covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers")))
{}
Map(c, covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers")))
Map(c, covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers"))
z <- Map(c, covs, c(std_pearson_corr_coef, cramers_v), c("pearson", "cramers"))
z[1]
z[2]
z[1]
z[2]
z[3]
z[1]
methods <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
methods$pearson
for c in covs{}
for (c in covs){}
for (c in covs){
bd
}
methods
names(methos)
names(methods)
methods
methods <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
methods
?list
as.pairlist(methods)
m <- names(methods)[1]
methods[m]
d = []
d <- c()
d
matrix(nrow=length(covs), ncols=len(methods))
matrix(nrow=length(covs), ncols=length(methods))
length(covs)
length(methods)
len(covs)
matrix(nrow=length(covs), ncols=length(methods))
matrix(nrow=length(covs), ncols=length(methods), dimnames = c("Covariates", "Metrics"))
matrix(nrow=length(covs), ncol=length(methods), dimnames = c("Covariates", "Metrics"))
matrix(nrow=length(covs), ncol=length(methods), dimnames = list("Covariates", "Metrics"))
list("Covariates", "Metrics")
list(covs, names(methods))
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
metric.mat[covs[1], names(methods)[1]]
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(methods)){
# Compute metric and place in appropriate slot
metric.mat[c, m] <- methods[m](bd)
}
}
m
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(methods)){
# Compute metric and place in appropriate slot
metric.mat[c, m] <- metrics[m](bd)
}
}
m
metrics[m]
metrics[m](bd)
bd
methods$pearson(bd)
m
metrics$pearson()
metrics$pearson
metrics[m]
metrics[m](bd)
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(methods)){
# Compute metric and place in appropriate slot
met <- metrics[m]
metric.mat[c, m] <- met(bd)
}
}
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(methods)){
# Compute metric and place in appropriate slot
metric.mat[c, m] <- metrics[m](bd)
}
}
metrics[m](bd)
metrics[m]()
metrics[m]
metrics[m]
t <- metrics[m]
t
t(bd)
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(methods)){
# Compute metric and place in appropriate slot
met <- metrics[m]
metric.mat[c, m] <- met(bd)
}
}
c(methods, names(methods))
c(methods, names(methods))[1]
x<-c(methods, names(methods))
View(x)
metrics
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(metrics)){
# Compute metric and place in appropriate slot
met <- metrics[m]
metric.mat[c, m] <- met(bd)
}
}
View(met)
# Compute metric and place in appropriate slot
met <- metrics[m]
met
# Compute metric and place in appropriate slot
met <- metrics[[m]]
metric.mat[c, m] <- metrics[[m]](bd)
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(metrics)){
# Compute metric and place in appropriate slot
met <- metrics[[m]]
metric.mat[c, m] <- metrics[[m]](bd)
}
}
metrics <- list("pearson"=std_pearson_corr_coef, "cramers"=cramers_v)
metrics
metrics[m]
metrics[[m]]
metric.mat
confound_metrics <- function(se){
metrics <- list("Pearson Correlation Coefficient"=std_pearson_corr_coef, "Cramer's V"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(metrics)){
# Compute metric and place in appropriate slot
metric.mat[c, m] <- metrics[[m]](bd)
}
}
# Add metrics to se
metadata(se)$confound.metrics <- metric.mat
}
conf\
confound_metrics <- function(se){
metrics <- list("Pearson Correlation Coefficient"=std_pearson_corr_coef, "Cramer's V"=cramers_v)
metric.mat <- matrix(nrow=length(covs), ncol=length(methods), dimnames = list(covs, names(metrics)))
for (c in covs){
# Get batch design
bd <- batch_design(se, c)
for (m in names(metrics)){
# Compute metric and place in appropriate slot
metric.mat[c, m] <- metrics[[m]](bd)
}
}
# Add metrics to se
return(metric.mat)
}
confound_metrics(se)
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
metadata(se)
View(se)
metadata(se)$confound.metrics <- confound_metrics(se)
View(se)
ingest_data <- function(counts_path, metadata_path){
require(SummarizedExperiment)
# Format for input:
## Counts must be a comma delimited csv file with header and sample name in the first row.
## Metadata is the same.
# Read in counts (assuming first column is index)
counts <- read.csv(counts_path, row.names=1,header=T)
# Read in metadata
md <- read.csv(metadata_path, row.names=1,header=T)
# CHECK that "Sample" and "Batch" columns are in md and find covariates
cols <- names(md)
covs <- cols[cols != 'Batch']
# Add in check of integrity: only create se object if all the samples in the metadata are presented in counts and vice versa, return NULL object else and capture the error later.
if (all(rownames(md)%in%colnames(counts))&all(colnames(counts)%in%rownames(md))) {
# Order the columns of the count data in the order of samples in metadata.
counts = counts[,match(rownames(md),colnames(counts))]
se <- SummarizedExperiment(list(counts=counts), colData=md)
# Add covariates
metadata(se)$covariates <- covs
# Get counfounding metrics
metadata(se)$confound.metrics <- confound_metrics(se)
}
else {
se = NULL
}
return(se)
}
se <- ingest_data('~/BatchQC/data/protein_data.csv', '~/BatchQC/data/protein_md.csv')
names(metadata(se))
runApp('inst/shiny')
metadata(se)$confound.metrics
runApp('inst/shiny')
runApp('inst/shiny')
runApp('inst/shiny')
